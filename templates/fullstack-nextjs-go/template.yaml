name: Fullstack (Next.js + Go)
type: fullstack
description: Fullstack app with Next.js frontend and Go backend
variables:
  - name: projectName
    description: Project name
    default: my-app
    required: true
    type: string
  - name: goModuleName
    description: Go module name
    default: github.com/example/my-app-api
    required: true
    type: string
  - name: typescript
    description: Use TypeScript in frontend
    default: "Yes"
    type: select
    options: ["Yes", "No"]
  - name: tailwind
    description: Use Tailwind CSS
    default: "Yes"
    type: select
    options: ["Yes", "No"]
  - name: useMongo
    description: Use MongoDB in backend
    default: "Yes"
    type: select
    options: ["Yes", "No"]
  - name: useRedis
    description: Use Redis in backend
    default: "Yes"
    type: select
    options: ["Yes", "No"]
files:
  # Frontend - package.json
  - path: frontend/package.json
    template: |
      {
        "name": "{{ .projectName }}-frontend",
        "version": "0.1.0",
        "private": true,
        "scripts": {
          "dev": "next dev",
          "build": "next build",
          "start": "next start",
          "lint": "next lint"
        },
        "dependencies": {
          "next": "^15.0.0",
          "react": "^19.0.0",
          "react-dom": "^19.0.0"
        },
        "devDependencies": {
          "@types/node": "^20",
          "@types/react": "^19",
          "@types/react-dom": "^19",
          "eslint": "^8",
          "eslint-config-next": "^15.0.0",
          "typescript": "^5"{{ if eq .tailwind "Yes" }},
          "tailwindcss": "^3.4.0",
          "postcss": "^8",
          "autoprefixer": "^10"{{ end }}
        }
      }
  # Frontend - Next.js config
  - path: frontend/next.config.js
    template: |
      /** @type {import('next').NextConfig} */
      const nextConfig = {
        env: {
          NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080',
        },
      }
      module.exports = nextConfig
  # Frontend - App router layout
  - path: frontend/app/layout.tsx
    condition: '{{ eq .typescript "Yes" }}'
    template: |
      import type { Metadata } from 'next'
      import '../styles/globals.css'

      export const metadata: Metadata = {
        title: '{{ .projectName }}',
        description: 'Fullstack app generated by Chrono CLI',
      }

      export default function RootLayout({
        children,
      }: {
        children: React.ReactNode
      }) {
        return (
          <html lang="en">
            <body>{children}</body>
          </html>
        )
      }
  # Frontend - Home page
  - path: frontend/app/page.tsx
    condition: '{{ eq .typescript "Yes" }}'
    template: |
      'use client'

      import { useState, useEffect } from 'react'

      type User = {
        id: string
        name: string
        email: string
      }

      export default function Home() {
        const [users, setUsers] = useState<User[]>([])
        const [loading, setLoading] = useState(true)

        useEffect(() => {
          fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/v1/users`)
            .then(res => res.json())
            .then(data => {
              setUsers(data.users || [])
              setLoading(false)
            })
            .catch(err => {
              console.error('Failed to fetch users:', err)
              setLoading(false)
            })
      }, [])

        const handleCreateUser = async () => {
          const name = prompt('Enter name:')
          const email = prompt('Enter email:')
          if (!name || !email) return

          const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/v1/users`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, email }),
          })

          if (res.ok) {
            const newUser = await res.json()
            setUsers([...users, newUser])
          }
        }

        return (
          <main className="min-h-screen p-8">
            <div className="max-w-4xl mx-auto">
              <header className="mb-8">
                <h1 className="text-4xl font-bold">{{ .projectName }}</h1>
                <p className="text-gray-600 mt-2">Fullstack app generated by Chrono CLI</p>
              </header>

              <section className="mb-8">
                <button
                  onClick={handleCreateUser}
                  className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                >
                  Create User
                </button>
              </section>

              <section>
                <h2 className="text-2xl font-semibold mb-4">Users</h2>
                {loading ? (
                  <p>Loading...</p>
                ) : users.length === 0 ? (
                  <p className="text-gray-500">No users yet. Create one!</p>
                ) : (
                  <ul className="space-y-2">
                    {users.map(user => (
                      <li key={user.id} className="p-4 border rounded">
                        <h3 className="font-medium">{user.name}</h3>
                        <p className="text-gray-600">{user.email}</p>
                      </li>
                    ))}
                  </ul>
                )}
              </section>
            </div>
          </main>
        )
      }
  # Frontend - Globals CSS
  - path: frontend/app/globals.css
    template: |
      {{ if eq .tailwind "Yes" }}@tailwind base;
      @tailwind components;
      @tailwind utilities;{{ else }}
      * {
        box-sizing: border-box;
        padding: 0;
        margin: 0;
      }

      html,
      body {
        max-width: 100vw;
        overflow-x: hidden;
      }

      body {
        min-height: 100vh;
      }

      main {
        display: flex;
        flex-direction: column;
      }
      {{ end }}
  # Frontend - Gitignore
  - path: frontend/.gitignore
    template: |
      # dependencies
      node_modules
      /.pnp
      .pnp.js

      # testing
      /coverage

      # next.js
      /.next/
      /out/

      # production
      /build

      # misc
      .DS_Store
      *.pem

      # debug
      npm-debug.log*
      yarn-debug.log*
      yarn-error.log*

      # vercel
      .vercel

      # typescript
      *.tsbuildinfo
      next-env.d.ts
  # Backend - go.mod
  - path: backend/go.mod
    template: |
      module {{ .goModuleName }}

      go 1.22

      require (
          github.com/gin-gonic/gin v1.10.0
          github.com/google/uuid v1.6.0
          log/slog v0.0.0{{ if eq .useMongo "Yes" }}
          go.mongodb.org/mongo-driver v1.15.0{{ end }}{{ if eq .useRedis "Yes" }}
          github.com/redis/go-redis/v9 v9.7.0{{ end }}
      )
  # Backend - main.go
  - path: backend/cmd/server/main.go
    template: |
      package main

      import (
          "context"
          "fmt"
          "log"
          "net/http"
          "os"
          "os/signal"
          "syscall"
          "time"

          "github.com/gin-gonic/gin"
          "log/slog"
          "{{ .goModuleName }}/internal/config"
          "{{ .goModuleName }}/internal/handler"
          "{{ .goModuleName }}/internal/repository"{{ if eq .useMongo "Yes" }}
          "{{ .goModuleName }}/internal/database"{{ end }}{{ if eq .useRedis "Yes" }}
          "{{ .goModuleName }}/internal/cache"{{ end }}
      )

      func main() {
          cfg := config.Load()

          logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
          slog.SetDefault(logger)

          slog.Info("starting {{ .projectName }} backend",
              "version", cfg.Version,
              "port", cfg.Port,
          )

          {{ if eq .useMongo "Yes" }}
          mongoClient, err := database.NewMongo(cfg.MongoDB.URI)
          if err != nil {
              slog.Error("failed to connect to mongodb", "error", err)
              os.Exit(1)
          }
          defer mongoClient.Disconnect(context.Background())
          db := mongoClient.Database(cfg.MongoDB.Database)
          {{ end }}

          {{ if eq .useRedis "Yes" }}
          redisClient := cache.NewRedis(cfg.Redis.URL)
          defer redisClient.Close()
          {{ end }}

          {{ if eq .useMongo "Yes" }}
          userRepo := repository.NewUserRepository(db)
          {{ else }}
          userRepo := repository.NewInMemoryUserRepository()
          {{ end }}

          healthHandler := handler.NewHealthHandler()
          userHandler := handler.NewUserHandler(userRepo)

          r := gin.Default()

          // CORS middleware for frontend
          r.Use(func(c *gin.Context) {
              c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
              c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
              c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
              c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

              if c.Request.Method == "OPTIONS" {
                  c.AbortWithStatus(204)
                  return
              }

              c.Next()
          })

          r.Use(handler.LoggerMiddleware())
          r.Use(handler.RecoveryMiddleware())

          r.GET("/health", healthHandler.Check)
          r.GET("/api/v1/users", userHandler.List)
          r.GET("/api/v1/users/:id", userHandler.Get)
          r.POST("/api/v1/users", userHandler.Create)

          srv := &http.Server{
              Addr:         fmt.Sprintf(":%s", cfg.Port),
              Handler:      r,
              ReadTimeout:  15 * time.Second,
              WriteTimeout: 15 * time.Second,
              IdleTimeout:  60 * time.Second,
          }

          go func() {
              slog.Info("backend server listening", "addr", srv.Addr)
              if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
                  log.Fatalf("server failed to start: %v", err)
              }
          }()

          quit := make(chan os.Signal, 1)
          signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
          <-quit

          slog.Info("shutting down server...")
          ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
          defer cancel()

          if err := srv.Shutdown(ctx); err != nil {
              slog.Error("server forced to shutdown", "error", err)
          }

          slog.Info("server stopped")
      }
  # Backend - config
  - path: backend/internal/config/config.go
    template: |
      package config

      import "os"

      type Config struct {
          Version string
          Port    string
          {{ if eq .useMongo "Yes" }}
          MongoDB MongoDBConfig
          {{ end }}
          {{ if eq .useRedis "Yes" }}
          Redis RedisConfig
          {{ end }}
      }

      {{ if eq .useMongo "Yes" }}
      type MongoDBConfig struct {
          URI      string
          Database string
      }
      {{ end }}

      {{ if eq .useRedis "Yes" }}
      type RedisConfig struct {
          URL string
      }
      {{ end }}

      func Load() *Config {
          return &Config{
              Version: getEnv("VERSION", "1.0.0"),
              Port:    getEnv("PORT", "8080"),
              {{ if eq .useMongo "Yes" }}
              MongoDB: MongoDBConfig{
                  URI:      getEnv("MONGODB_URI", "mongodb://localhost:27017"),
                  Database: getEnv("MONGODB_DATABASE", "{{ .projectName }}"),
              },
              {{ end }}
              {{ if eq .useRedis "Yes" }}
              Redis: RedisConfig{
                  URL: getEnv("REDIS_URL", "redis://localhost:6379"),
              },
              {{ end }}
          }
      }

      func getEnv(key, defaultVal string) string {
          if val := os.Getenv(key); val != "" {
              return val
          }
          return defaultVal
      }
  # Backend - handlers (simplified)
  - path: backend/internal/handler/health.go
    template: |
      package handler

      import (
          "net/http"

          "github.com/gin-gonic/gin"
      )

      type HealthHandler struct{}

      func NewHealthHandler() *HealthHandler {
          return &HealthHandler{}
      }

      func (h *HealthHandler) Check(c *gin.Context) {
          c.JSON(http.StatusOK, gin.H{
              "status": "healthy",
          })
      }
  - path: backend/internal/handler/user.go
    template: |
      package handler

      import (
          "net/http"

          "github.com/gin-gonic/gin"
          "github.com/google/uuid"
          "{{ .goModuleName }}/internal/repository"
      )

      type UserHandler struct {
          repo repository.UserRepository
      }

      func NewUserHandler(repo repository.UserRepository) *UserHandler {
          return &UserHandler{repo: repo}
      }

      type CreateUserRequest struct {
          Name  string `json:"name" binding:"required"`
          Email string `json:"email" binding:"required,email"`
      }

      func (h *UserHandler) Create(c *gin.Context) {
          var req CreateUserRequest
          if err := c.ShouldBindJSON(&req); err != nil {
              c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
              return
          }

          user := &repository.User{
              ID:    uuid.New().String(),
              Name:  req.Name,
              Email: req.Email,
          }

          if err := h.repo.Create(user); err != nil {
              c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create user"})
              return
          }

          c.JSON(http.StatusCreated, user)
      }

      func (h *UserHandler) Get(c *gin.Context) {
          id := c.Param("id")
          user, err := h.repo.Get(id)
          if err != nil {
              c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
              return
          }

          c.JSON(http.StatusOK, user)
      }

      func (h *UserHandler) List(c *gin.Context) {
          users, err := h.repo.List()
          if err != nil {
              c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list users"})
              return
          }

          c.JSON(http.StatusOK, gin.H{"users": users})
      }
  - path: backend/internal/handler/middleware.go
    template: |
      package handler

      import (
          "log/slog"
          "time"

          "github.com/gin-gonic/gin"
      )

      func LoggerMiddleware() gin.HandlerFunc {
          return func(c *gin.Context) {
              start := time.Now()
              path := c.Request.URL.Path
              query := c.Request.URL.RawQuery

              c.Next()

              slog.Info("request",
                  "method", c.Request.Method,
                  "path", path,
                  "query", query,
                  "status", c.Writer.Status(),
                  "latency", time.Since(start),
              )
          }
      }

      func RecoveryMiddleware() gin.HandlerFunc {
          return gin.Recovery()
      }
  # Backend - repository (simplified in-memory)
  - path: backend/internal/repository/user.go
    template: |
      package repository

      import (
          "context"
          {{ if eq .useMongo "Yes" }}
          "time"

          "go.mongodb.org/mongo-driver/bson"
          "go.mongodb.org/mongo-driver/mongo"
          {{ end }}
      )

      type User struct {
          ID        string `json:"id" bson:"_id"`
          Name      string `json:"name" bson:"name"`
          Email     string `json:"email" bson:"email"`
          CreatedAt string `json:"created_at,omitempty" bson:"created_at,omitempty"`
      }

      type UserRepository interface {
          Create(user *User) error
          Get(id string) (*User, error)
          List() ([]*User, error)
      }

      {{ if eq .useMongo "Yes" }}
      type mongoUserRepository struct {
          collection *mongo.Collection
      }

      func NewUserRepository(db *mongo.Database) UserRepository {
          return &mongoUserRepository{
              collection: db.Collection("users"),
          }
      }

      func (r *mongoUserRepository) Create(user *User) error {
          user.CreatedAt = time.Now().Format(time.RFC3339)
          _, err := r.collection.InsertOne(context.Background(), user)
          return err
      }

      func (r *mongoUserRepository) Get(id string) (*User, error) {
          var user User
          err := r.collection.FindOne(context.Background(), bson.M{"_id": id}).Decode(&user)
          if err != nil {
              return nil, err
          }
          return &user, nil
      }

      func (r *mongoUserRepository) List() ([]*User, error) {
          var users []*User
          cursor, err := r.collection.Find(context.Background(), bson.M{})
          if err != nil {
              return nil, err
          }
          defer cursor.Close(context.Background())

          for cursor.Next(context.Background()) {
              var user User
              if err := cursor.Decode(&user); err == nil {
                  users = append(users, &user)
              }
          }

          return users, nil
      }
      {{ else }}
      type inMemoryUserRepository struct {
          users map[string]*User
      }

      func NewInMemoryUserRepository() UserRepository {
          return &inMemoryUserRepository{
              users: make(map[string]*User),
          }
      }

      func (r *inMemoryUserRepository) Create(user *User) error {
          r.users[user.ID] = user
          return nil
      }

      func (r *inMemoryUserRepository) Get(id string) (*User, error) {
          user, ok := r.users[id]
          if !ok {
              return nil, nil
          }
          return user, nil
      }

      func (r *inMemoryUserRepository) List() ([]*User, error) {
          users := make([]*User, 0, len(r.users))
          for _, user := range r.users {
              users = append(users, user)
          }
          return users, nil
      }
      {{ end }}
      {{ if eq .useMongo "Yes" }}
      - path: backend/internal/database/mongo.go
        template: |
          package database

          import (
              "context"
              "log/slog"

              "go.mongodb.org/mongo-driver/mongo"
              "go.mongodb.org/mongo-driver/mongo/options"
          )

          func NewMongo(uri string) (*mongo.Client, error) {
              client, err := mongo.Connect(context.Background(), options.Client().ApplyURI(uri))
              if err != nil {
                  return nil, err
              }

              if err := client.Ping(context.Background(), nil); err != nil {
                  return nil, err
              }

              slog.Info("connected to mongodb")
              return client, nil
          }
      {{ end }}
      {{ if eq .useRedis "Yes" }}
      - path: backend/internal/cache/redis.go
        template: |
          package cache

          import (
              "context"
              "log/slog"

              "github.com/redis/go-redis/v9"
          )

          func NewRedis(url string) *redis.Client {
              opt, err := redis.ParseURL(url)
              if err != nil {
                  panic(err)
              }

              client := redis.NewClient(opt)

              if err := client.Ping(context.Background()).Err(); err != nil {
                  slog.Error("failed to connect to redis", "error", err)
              } else {
                  slog.Info("connected to redis")
              }

              return client
          }
      {{ end }}
  # Root files
  - path: .gitignore
    template: |
      # Frontend
      frontend/node_modules
      frontend/.next
      frontend/out
      frontend/build

      # Backend
      backend/bin
      backend/dist

      # IDE
      .idea/
      .vscode/
      *.swp

      # OS
      .DS_Store

      # Environment
      .env
      .env.local

      # Chrono
      .chrono/
  - path: docker-compose.yml
    template: |
      version: '3.8'

      services:
        {{ if eq .useMongo "Yes" }}
        mongodb:
          image: mongo:8
          ports:
            - "27017:27017"
          environment:
            MONGO_INITDB_DATABASE: {{ .projectName }}
          volumes:
            - mongodb_data:/data/db

        {{ end }}
        {{ if eq .useRedis "Yes" }}
        redis:
          image: redis:7-alpine
          ports:
            - "6379:6379"

        {{ end }}
        backend:
          build:
            context: ./backend
            dockerfile: Dockerfile
          ports:
            - "8080:8080"
          environment:
            {{ if eq .useMongo "Yes" }}
            MONGODB_URI: mongodb://mongodb:27017
            MONGODB_DATABASE: {{ .projectName }}
            {{ end }}
            {{ if eq .useRedis "Yes" }}
            REDIS_URL: redis://redis:6379
            {{ end }}
            PORT: 8080
          {{ if eq .useMongo "Yes" }}
          depends_on:
            - mongodb
          {{ end }}
          {{ if eq .useRedis "Yes" }}
          depends_on:
            - redis
          {{ end }}

        frontend:
          build:
            context: ./frontend
            dockerfile: Dockerfile
          ports:
            - "3000:3000"
          environment:
            NEXT_PUBLIC_API_URL: http://localhost:8080
          depends_on:
            - backend

      {{ if eq .useMongo "Yes" }}
      volumes:
        mongodb_data:
      {{ end }}
  - path: README.md
    template: |
      # {{ .projectName }}

      Fullstack application generated by [Chrono CLI](https://github.com/aelfdevops/chrono).

      ## Stack

      - **Frontend**: Next.js 15{{ if eq .typescript "Yes" }} + TypeScript{{ end }}{{ if eq .tailwind "Yes" }} + Tailwind CSS{{ end }}
      - **Backend**: Go 1.22 + Gin{{ if eq .useMongo "Yes" }} + MongoDB{{ end }}{{ if eq .useRedis "Yes" }} + Redis{{ end }}

      ## Getting Started

      ### Development

      ```bash
      # Frontend
      cd frontend
      npm install
      npm run dev

      # Backend (in another terminal)
      cd backend
      go mod download
      make run
      ```

      ### With Docker

      ```bash
      docker-compose up
      ```

      - Frontend: http://localhost:3000
      - Backend: http://localhost:8080
      - Health: http://localhost:8080/health

      ## Deploy with Chrono

      ```bash
      chrono login
      chrono skill install deploy.md
      ```

      Then use the `/deploy` command in Cursor IDE.

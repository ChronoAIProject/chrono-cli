name: Go
type: backend
description: High-performance Go backend with Gin framework, MongoDB, and Redis
variables:
  - name: projectName
    description: Project name (will be converted to lowercase for module path)
    default: my-service
    required: true
    type: string
  - name: moduleName
    description: Go module name
    default: github.com/example/my-service
    required: true
    type: string
  - name: useMongo
    description: Use MongoDB
    default: "Yes"
    type: select
    options: ["Yes", "No"]
  - name: useRedis
    description: Use Redis
    default: "Yes"
    type: select
    options: ["Yes", "No"]
files:
  - path: go.mod
    template: |
      module {{ .moduleName }}

      go 1.22

      require (
        github.com/gin-gonic/gin v1.10.0
        github.com/google/uuid v1.6.0
        log/slog v0.0.0{{ if eq .useMongo "Yes" }}
        go.mongodb.org/mongo-driver v1.15.0{{ end }}{{ if eq .useRedis "Yes" }}
        github.com/redis/go-redis/v9 v9.7.0{{ end }}
      )
  - path: cmd/server/main.go
    template: |
      package main

      import (
          "context"
          "fmt"
          "log"
          "net/http"
          "os"
          "os/signal"
          "syscall"
          "time"

          "github.com/gin-gonic/gin"
          "log/slog"
          "{{ .moduleName }}/internal/config"
          "{{ .moduleName }}/internal/handler"
          "{{ .moduleName }}/internal/repository"{{ if eq .useMongo "Yes" }}
          "{{ .moduleName }}/internal/database"{{ end }}{{ if eq .useRedis "Yes" }}
          "{{ .moduleName }}/internal/cache"{{ end }}
      )

      func main() {
          // Load configuration
          cfg := config.Load()

          // Initialize logger
          logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
          slog.SetDefault(logger)

          slog.Info("starting {{ .projectName }}",
              "version", cfg.Version,
              "port", cfg.Port,
          )

          {{ if eq .useMongo "Yes" }}
          // Initialize MongoDB
          mongoClient, err := database.NewMongo(cfg.MongoDB.URI)
          if err != nil {
              slog.Error("failed to connect to mongodb", "error", err)
              os.Exit(1)
          }
          defer mongoClient.Disconnect(context.Background())

          db := mongoClient.Database(cfg.MongoDB.Database)
          {{ end }}

          {{ if eq .useRedis "Yes" }}
          // Initialize Redis
          redisClient := cache.NewRedis(cfg.Redis.URL)
          defer redisClient.Close()
          {{ end }}

          // Initialize repositories
          {{ if eq .useMongo "Yes" }}
          userRepo := repository.NewUserRepository(db)
          {{ else }}
          userRepo := repository.NewInMemoryUserRepository()
          {{ end }}

          // Initialize handlers
          healthHandler := handler.NewHealthHandler()
          userHandler := handler.NewUserHandler(userRepo)

          // Setup router
          r := gin.Default()

          // Middleware
          r.Use(handler.LoggerMiddleware())
          r.Use(handler.RecoveryMiddleware())

          // Routes
          r.GET("/health", healthHandler.Check)
          r.GET("/api/v1/users", userHandler.List)
          r.GET("/api/v1/users/:id", userHandler.Get)
          r.POST("/api/v1/users", userHandler.Create)

          // Start server
          srv := &http.Server{
              Addr:         fmt.Sprintf(":%s", cfg.Port),
              Handler:      r,
              ReadTimeout:  15 * time.Second,
              WriteTimeout: 15 * time.Second,
              IdleTimeout:  60 * time.Second,
          }

          go func() {
              slog.Info("server listening", "addr", srv.Addr)
              if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
                  log.Fatalf("server failed to start: %v", err)
              }
          }()

          // Graceful shutdown
          quit := make(chan os.Signal, 1)
          signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
          <-quit

          slog.Info("shutting down server...")
          ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
          defer cancel()

          if err := srv.Shutdown(ctx); err != nil {
              slog.Error("server forced to shutdown", "error", err)
          }

          slog.Info("server stopped")
      }
  - path: internal/config/config.go
    template: |
      package config

      import (
          "os"
      )

      type Config struct {
          Version string
          Port    string
          {{ if eq .useMongo "Yes" }}
          MongoDB MongoDBConfig
          {{ end }}
          {{ if eq .useRedis "Yes" }}
          Redis RedisConfig
          {{ end }}
      }

      {{ if eq .useMongo "Yes" }}
      type MongoDBConfig struct {
          URI      string
          Database string
      }
      {{ end }}

      {{ if eq .useRedis "Yes" }}
      type RedisConfig struct {
          URL string
      }
      {{ end }}

      func Load() *Config {
          return &Config{
              Version: getEnv("VERSION", "1.0.0"),
              Port:    getEnv("PORT", "8080"),
              {{ if eq .useMongo "Yes" }}
              MongoDB: MongoDBConfig{
                  URI:      getEnv("MONGODB_URI", "mongodb://localhost:27017"),
                  Database: getEnv("MONGODB_DATABASE", "{{ .projectName }}"),
              },
              {{ end }}
              {{ if eq .useRedis "Yes" }}
              Redis: RedisConfig{
                  URL: getEnv("REDIS_URL", "redis://localhost:6379"),
              },
              {{ end }}
          }
      }

      func getEnv(key, defaultVal string) string {
          if val := os.Getenv(key); val != "" {
              return val
          }
          return defaultVal
      }
  - path: internal/handler/health.go
    template: |
      package handler

      import (
          "net/http"

          "github.com/gin-gonic/gin"
      )

      type HealthHandler struct{}

      func NewHealthHandler() *HealthHandler {
          return &HealthHandler{}
      }

      func (h *HealthHandler) Check(c *gin.Context) {
          c.JSON(http.StatusOK, gin.H{
              "status": "healthy",
          })
      }
  - path: internal/handler/user.go
    template: |
      package handler

      import (
          "net/http"

          "github.com/gin-gonic/gin"
          "github.com/google/uuid"
          "{{ .moduleName }}/internal/repository"
      )

      type UserHandler struct {
          repo repository.UserRepository
      }

      func NewUserHandler(repo repository.UserRepository) *UserHandler {
          return &UserHandler{repo: repo}
      }

      type CreateUserRequest struct {
          Name  string `json:"name" binding:"required"`
          Email string `json:"email" binding:"required,email"`
      }

      func (h *UserHandler) Create(c *gin.Context) {
          var req CreateUserRequest
          if err := c.ShouldBindJSON(&req); err != nil {
              c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
              return
          }

          user := &repository.User{
              ID:    uuid.New().String(),
              Name:  req.Name,
              Email: req.Email,
          }

          if err := h.repo.Create(user); err != nil {
              c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create user"})
              return
          }

          c.JSON(http.StatusCreated, user)
      }

      func (h *UserHandler) Get(c *gin.Context) {
          id := c.Param("id")
          user, err := h.repo.Get(id)
          if err != nil {
              c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
              return
          }

          c.JSON(http.StatusOK, user)
      }

      func (h *UserHandler) List(c *gin.Context) {
          users, err := h.repo.List()
          if err != nil {
              c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list users"})
              return
          }

          c.JSON(http.StatusOK, gin.H{"users": users})
      }
  - path: internal/handler/middleware.go
    template: |
      package handler

      import (
          "log/slog"
          "time"

          "github.com/gin-gonic/gin"
      )

      func LoggerMiddleware() gin.HandlerFunc {
          return func(c *gin.Context) {
              start := time.Now()
              path := c.Request.URL.Path
              query := c.Request.URL.RawQuery

              c.Next()

              slog.Info("request",
                  "method", c.Request.Method,
                  "path", path,
                  "query", query,
                  "status", c.Writer.Status(),
                  "latency", time.Since(start),
              )
          }
      }

      func RecoveryMiddleware() gin.HandlerFunc {
          return gin.Recovery()
      }
  - path: internal/repository/user.go
    template: |
      package repository

      import (
          "context"
          {{ if eq .useMongo "Yes" }}
          "time"

          "go.mongodb.org/mongo-driver/bson"
          "go.mongodb.org/mongo-driver/mongo"
          {{ end }}
      )

      type User struct {
          ID        string `json:"id" bson:"_id"`
          Name      string `json:"name" bson:"name"`
          Email     string `json:"email" bson:"email"`
          CreatedAt string `json:"created_at,omitempty" bson:"created_at,omitempty"`
      }

      type UserRepository interface {
          Create(user *User) error
          Get(id string) (*User, error)
          List() ([]*User, error)
      }

      {{ if eq .useMongo "Yes" }}
      type mongoUserRepository struct {
          collection *mongo.Collection
      }

      func NewUserRepository(db *mongo.Database) UserRepository {
          return &mongoUserRepository{
              collection: db.Collection("users"),
          }
      }

      func (r *mongoUserRepository) Create(user *User) error {
          user.CreatedAt = time.Now().Format(time.RFC3339)
          _, err := r.collection.InsertOne(context.Background(), user)
          return err
      }

      func (r *mongoUserRepository) Get(id string) (*User, error) {
          var user User
          err := r.collection.FindOne(context.Background(), bson.M{"_id": id}).Decode(&user)
          if err != nil {
              return nil, err
          }
          return &user, nil
      }

      func (r *mongoUserRepository) List() ([]*User, error) {
          var users []*User
          cursor, err := r.collection.Find(context.Background(), bson.M{})
          if err != nil {
              return nil, err
          }
          defer cursor.Close(context.Background())

          for cursor.Next(context.Background()) {
              var user User
              if err := cursor.Decode(&user); err == nil {
                  users = append(users, &user)
              }
          }

          return users, nil
      }
      {{ else }}
      type inMemoryUserRepository struct {
          users map[string]*User
      }

      func NewInMemoryUserRepository() UserRepository {
          return &inMemoryUserRepository{
              users: make(map[string]*User),
          }
      }

      func (r *inMemoryUserRepository) Create(user *User) error {
          r.users[user.ID] = user
          return nil
      }

      func (r *inMemoryUserRepository) Get(id string) (*User, error) {
          user, ok := r.users[id]
          if !ok {
              return nil, nil
          }
          return user, nil
      }

      func (r *inMemoryUserRepository) List() ([]*User, error) {
          users := make([]*User, 0, len(r.users))
          for _, user := range r.users {
              users = append(users, user)
          }
          return users, nil
      }
      {{ end }}
  {{ if eq .useMongo "Yes" }}
  - path: internal/database/mongo.go
    template: |
      package database

      import (
          "context"
          "log/slog"

          "go.mongodb.org/mongo-driver/mongo"
          "go.mongodb.org/mongo-driver/mongo/options"
      )

      func NewMongo(uri string) (*mongo.Client, error) {
          client, err := mongo.Connect(context.Background(), options.Client().ApplyURI(uri))
          if err != nil {
              return nil, err
          }

          if err := client.Ping(context.Background(), nil); err != nil {
              return nil, err
          }

          slog.Info("connected to mongodb")
          return client, nil
      }
  {{ end }}
  {{ if eq .useRedis "Yes" }}
  - path: internal/cache/redis.go
    template: |
      package cache

      import (
          "context"
          "log/slog"

          "github.com/redis/go-redis/v9"
      )

      func NewRedis(url string) *redis.Client {
          opt, err := redis.ParseURL(url)
          if err != nil {
              panic(err)
          }

          client := redis.NewClient(opt)

          // Test connection
          if err := client.Ping(context.Background()).Err(); err != nil {
              slog.Error("failed to connect to redis", "error", err)
          } else {
              slog.Info("connected to redis")
          }

          return client
      }
  {{ end }}
  - path: .gitignore
    template: |
      # Binaries for programs and plugins
      *.exe
      *.exe~
      *.dll
      *.so
      *.dylib
      *.test
      *.out

      # Go workspace file
      go.work

      # Dependency directories
      vendor/

      # Build output
      /bin
      /dist

      # IDE
      .idea/
      .vscode/
      *.swp
      *.swo
      *~

      # OS
      .DS_Store
      Thumbs.db

      # Environment
      .env
      .env.local

      # chrono
      .chrono/
  - path: Dockerfile
    template: |
      # Build stage
      FROM golang:1.22-alpine AS builder

      WORKDIR /app
      COPY go.mod go.sum ./
      RUN go mod download

      COPY . .
      RUN CGO_ENABLED=0 go build -o {{ .projectName }} ./cmd/server

      # Runtime stage
      FROM alpine:latest

      RUN apk --no-cache add ca-certificates
      WORKDIR /root/

      COPY --from=builder /app/{{ .projectName }} .
      COPY --from=builder /app/internal ./internal

      EXPOSE 8080

      CMD ["./{{ .projectName }}"]
  - path: Makefile
    template: |
      .PHONY: build run test clean

      APP_NAME={{ .projectName }}

      build:
          go build -o bin/$(APP_NAME) ./cmd/server

      run:
          go run ./cmd/server/main.go

      test:
          go test -v ./...

      clean:
          rm -rf bin/

      docker-build:
          docker build -t $(APP_NAME):latest .

      docker-run:
          docker run -p 8080:8080 $(APP_NAME):latest
  - path: README.md
    template: |
      # {{ .projectName }}

      High-performance Go backend service generated by [Chrono CLI](https://github.com/aelfdevops/chrono).

      ## Features

      - ✅ Go 1.22
      - ✅ Gin framework
      - ✅ Structured logging (slog)
      - ✅ Graceful shutdown
      {{ if eq .useMongo "Yes" }}- ✅ MongoDB integration{{ end }}
      {{ if eq .useRedis "Yes" }}- ✅ Redis cache{{ end }}

      ## Getting Started

      ```bash
      # Install dependencies
      go mod download

      # Run development server
      make run

      # Or build and run
      make build
      ./bin/{{ .projectName }}
      ```

      API: http://localhost:8080
      Health: http://localhost:8080/health

      ## Deploy with Chrono

      ```bash
      chrono login
      chrono skill install deploy.md
      ```

      Then use the `/deploy` command in Cursor IDE.
